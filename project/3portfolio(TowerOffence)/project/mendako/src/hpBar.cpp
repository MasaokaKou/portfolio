//---------------------------------------------------------------------------
//!	@file	HpBar.cpp
//!	@brief	HpBar実装
//---------------------------------------------------------------------------

//===========================================================================
//! HPBar
//===========================================================================

//---------------------------------------------------------------------------
//! コンストラクタ
//---------------------------------------------------------------------------
HpBar::HpBar()
{
    _wide = 50.0f;
    _hide = 10.0f;

    _front_alpha = 0;

    // OBJECTがダメージを受けたら
    _is_damage = false;
    // TYPEDに攻撃されているかどうか
    _is_heal = false;

    // アニメーション
    // 後ろのHPBar
    _back_wide = _wide;

    // wideが削れてからback_wideが削れるまでの感覚
    _anim_count = 50;
    // 後ろが削れ始めるまでのフラグ
    _anim_flag = false;
    _alpha     = 0;
}

//---------------------------------------------------------------------------
//! デストラクタ
//---------------------------------------------------------------------------
HpBar ::~HpBar()
{
}

//---------------------------------------------------------------------------
//! 初期化
//---------------------------------------------------------------------------
bool HpBar::initialize(s16 max_hp_)
{
    _max_hp = max_hp_;

    return true;
}

//---------------------------------------------------------------------------
//! 更新
//---------------------------------------------------------------------------
void HpBar::update()
{
    //! hpとwideを連動

    _rate = 50 / _max_hp;

    _wide = _hp * _rate;

    //! スクリーン座標に変換
    _scr_pos = ConvWorldPosToScreenPos(_pos);

    animation();
}
//---------------------------------------------------------------------------
//! 描画
//---------------------------------------------------------------------------
void HpBar::render()
{
    if(_wide <= 0)
        return;

    SetDrawBlendMode(DX_BLENDMODE_ALPHA, _alpha);
    DrawBox(_scr_pos.x, _scr_pos.y, _scr_pos.x + _back_wide, _scr_pos.y + _hide, WHITE, true);
    SetDrawBlendMode(DX_BLENDMODE_NOBLEND, 0);

    SetDrawBlendMode(DX_BLENDMODE_ALPHA, _front_alpha);

    if(_wide <= 50 * 0.3) {
        DrawBox(_scr_pos.x, _scr_pos.y, _scr_pos.x + _wide, _scr_pos.y + _hide, RED, true);
    }
    else {
        DrawBox(_scr_pos.x, _scr_pos.y, _scr_pos.x + _wide, _scr_pos.y + _hide, WHITE, true);
    }
    DrawBox(_scr_pos.x, _scr_pos.y, _scr_pos.x + 50.0f, _scr_pos.y + _hide, BLACK, false);

    SetDrawBlendMode(DX_BLENDMODE_NOBLEND, 0);
}

//---------------------------------------------------------------------------
//! 解放
//---------------------------------------------------------------------------
void HpBar::finalize()
{
}

//---------------------------------------------------------------------------
//! posの受け渡し
//---------------------------------------------------------------------------
void HpBar::prPos(VECTOR pos_)
{
    _pos = pos_;
}

//---------------------------------------------------------------------------
//! HPの受け渡し
//---------------------------------------------------------------------------
void HpBar::setHp(s16 hp_)
{
    _hp = hp_;
}

void HpBar::type(s16 type_)
{
    _type = type_;
}

//---------------------------------------------------------------------------
// アニメーション
//---------------------------------------------------------------------------
void HpBar::animation()
{
    if(_wide != _back_wide) {
        _anim_count--;
    }

    if(decCount()) {
        if(_wide <= _back_wide) {
            _back_wide -= 1.5f;
        }
        else {
            _anim_count = 50;
        }
    }

    if(_hp == _max_hp) {
        if(_front_alpha <= 0) {
            return;
        }
        _front_alpha--;
    }

    if(_hp < _max_hp) {
        if(_alpha < 155) {
            _alpha += 5;
        }

        if(_front_alpha >= 200) {
            return;
        }
        _front_alpha += 4;
    }
}

//---------------------------------------------------------------------------
//! カウント減少
//---------------------------------------------------------------------------
bool HpBar::decCount()
{
    if(_anim_count <= 0) {
        return true;
    }

    return false;
}

void HpBar::setPos(VECTOR v_)
{
    _scr_pos = VGet(_scr_pos.x + v_.x, _scr_pos.y + v_.y, _scr_pos.z + v_.z);
}
