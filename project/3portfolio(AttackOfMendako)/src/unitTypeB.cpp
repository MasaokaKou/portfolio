//---------------------------------------------------------------------------
//!	@file	unitTypeB.cpp
//!	@brief	UnitTypeBの実装
//---------------------------------------------------------------------------
#include "unitTypeB.h"

//---------------------------------------------------------------------------
//! コンストラクタ
//---------------------------------------------------------------------------
UnitTypeB::UnitTypeB()
{
    // ユニットの種類
    _type = TYPE::TYPE_B;
    _pos  = VGet(0, 0, 0);   // 位置座標
    //_size = 0.04f;           // 図形描画の際のサイズ

    _HP         = 5;
    par._hp     = _HP;    // 耐久値
    par._atk    = 2;      // 攻撃力
    par._def    = 0;      // 耐久力
    par._movSpd = 0.4f;   // 進軍速度
    par._atkSpd = 60;     //攻撃速度(_atkSpd フレームに一度)

    // 当たり判定用の変数(索敵)
    _hit._hcPos   = VGet(_pos.x, _pos.y, _pos.z);   // 現在位置
    _hit._hcScale = 40;                             // サイズ
    _hit._hcSpace = 0;                              // 間隔

    // 当たり判定用の変数(攻撃)
    _hitAtk._hcPos = VGet(_pos.x, _pos.y, _pos.z);   // 現在位置
    //_hitAtk._hcScale = 1;                              // サイズ
    //_hitAtk._hcSpace = 500;
    _hitAtk._hcScale = 20;
    _hitAtk._hcSpace = 0;

    // 遠距離攻撃のモデル（ウニ）
    _model = std::make_unique<Model>();   // 実態作成

    // 行列
    _mat = MGetIdent();                         // 単位行列を取得
    _mat = MGetScale(VGet(0.01, 0.01, 0.01));   // サイズ指定

    _mat.m[3][1] = 2;
}

//---------------------------------------------------------------------------
//! デストラクタ
//---------------------------------------------------------------------------
UnitTypeB::~UnitTypeB()
{
}

//---------------------------------------------------------------------------
//! 初期化
//---------------------------------------------------------------------------
bool UnitTypeB::initialize()
{
    UnitBase::initialize("data/Unit/Unit.mqo", "data/Unit/unitTypeB.png");

    _model.get()->load("data/Unit/uni.mqo");

    return true;
}

//---------------------------------------------------------------------------
//! 更新
//---------------------------------------------------------------------------
void UnitTypeB::update()
{
    UnitBase::update();

    if((_state == STATE::WAIT || _state == STATE::MOVE)) {
        //! マトリックスの座標に現在位置を入れる
        _mat.m[3][0] = _pos.x;
        _mat.m[3][2] = _pos.z;
    }

    if(_mat.m[3][1] <= 7.0f) {
        _mat.m[3][1] += 0.05f;
    }

    //! マトリックス設定
    MV1SetMatrix(_model.get()->handle(), _mat);
}
//---------------------------------------------------------------------------
//! 描画
//---------------------------------------------------------------------------
void UnitTypeB::render()
{
    _model.get()->draw();
    UnitBase::render();
}

//---------------------------------------------------------------------------
//! 解放
//---------------------------------------------------------------------------
void UnitTypeB::finalize()
{
    UnitBase::finalize();
}

//---------------------------------------------------------------------------
//! 遠距離武器の動き
//---------------------------------------------------------------------------
void UnitTypeB::atkMove(VECTOR fac_pos_, f32 fac_size_, STATE state_)
{
    if(_state != STATE::ATTACK) {
        return;
    }

    //! 武器から攻撃用当たり判定へのベクトル作成
    VECTOR dir;

    //! 索敵範囲に入ってる敵に
    if(UnitBase::search(fac_pos_, fac_size_, state_)) {
        //! モデルの座標から攻撃用当たり判定の座標を引く
        dir = VSub(fac_pos_, VGet(_mat.m[3][0], _mat.m[3][1], _mat.m[3][2]));

        // 正規化
        dir = VNorm(dir);

        //! 正規化したベクトルに速度をかける
        dir = VScale(dir, 1);

        //! Unitの座標に正規化した方向ベクトルを足す
        //_model_pos = VAdd(_pos, dir);
        _mat.m[3][0] = _mat.m[3][0] + dir.x;
        _mat.m[3][2] = _mat.m[3][2] + dir.z;

        if(dir.x <= 0.01f && dir.x >= -0.01f) {
            _mat.m[3][0] = _pos.x;
            _mat.m[3][1] = 8;
            _mat.m[3][2] = _pos.z;
        }
    }
}
